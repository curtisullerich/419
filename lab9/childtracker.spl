//TO RUN: ./output/bin/standalone stream="SensorData.csv" details="ChildDetails.csv"
composite childtracker {
  graph 
    //read in both files as CSVs
    stream<rstring time, rstring sensorid, rstring childid, rstring fromroom, rstring toroom> LineStream = FileSource() { 
      param 
        format : csv;
        hasHeaderLine : false;
        //defaultTuple : {time = "0", sensorid="default", childid="default", fromroom="default", toroom="default" };
        file : getSubmissionTimeValue("stream");
    }
 
    stream<rstring time, rstring childid, rstring parentname, rstring childname, rstring phone> LineStream2 = FileSource() { 
      param 
        format : csv;
        hasHeaderLine : false;
        //defaultTuple : {time = "0", childid="default", parent="default", phone="0" };
        file : getSubmissionTimeValue("details");
    }
   
    stream<rstring time, rstring id, rstring rm> PartA = Custom(LineStream) {
      logic
        state: {

          //map of childid, {timestamp, room}
          mutable map<rstring, tuple<int64 time, rstring room>> tracks = {};

          mutable int64 previous = -1l;
        }

        onTuple LineStream : {

          //parse the time into its components
          mutable int64 hour = -1;
          mutable int64 minute = -1;
          mutable float64 second = -1;

          list<rstring> components = tokenize(time, ":", false);
          parseNumber(hour,components[0]);
          parseNumber(minute,components[1]);
          parseNumber(second,components[2]);

          mutable int64 current = hour*60l*60l + minute*60l + (int64) second;

          tracks[childid] = {time=current, room=toroom};

          if (previous == -1l) {
            //TODO don't set to current, just increment by 5
            previous = current;
          } else {
            if (current - previous > 5l*60l) {
              previous = current;
              //output!

             for (rstring k in tracks) {
                mutable int64 t = tracks[k].time;
                int64 s = t % 60l;
                t = t / 60l;
                minute = t % 60l;
                t = t / 60l;
                hour = t;
                 
                mutable rstring timeasdf = "";
                if (hour < 10l) {
                  timeasdf += "0";
                }
                timeasdf += (rstring) hour + ":";
                if (minute < 10l) {
                  timeasdf += "0";
                }
                timeasdf += (rstring) minute + ":";
                if (s < 10l) {
                  timeasdf += "0";
                }
                timeasdf += (rstring) s;
                
                submit({time=timeasdf, id=k, rm=tracks[k].room}, PartA);
              }
            } else {
              //nothing. just keep collecting.
            }
          }
        }          
    }

    stream<rstring time, rstring id, rstring phone> PartC = Custom(LineStream) {
      logic
        state: {

          //map of childid, timestamp
          mutable map<rstring, int64> tracks = {};
          //map of childid, alarmsounded
          mutable map<rstring, boolean> alarmed = {};
        }

        onTuple LineStream : {
      //Linestream: <rstring time, rstring sensorid, rstring childid, rstring fromroom, rstring toroom>
          mutable int64 hour = -1;
          mutable int64 minute = -1;
          mutable float64 second = -1;

          list<rstring> components = tokenize(time, ":", false);
          parseNumber(hour,components[0]);
          parseNumber(minute,components[1]);
          parseNumber(second,components[2]);

          mutable int64 current = hour*60l*60l + minute*60l + (int64) second;
          if (toroom == "26") {
            //parse the time into its components
            tracks[childid] = current;
            alarmed[childid] = false;
          }
          if (fromroom == "26") {
            //alarmed[childid] = false;
          }

          //gives us the value of the current time
          for (rstring k in tracks) {

            //compare NOW to the entry point for the child and see if it's been 5 minutes
            if (current - tracks[k] > 5l*60l) {
              //danger!

              //all this string parsing was just helpful for debugging. remove before submission.
              mutable int64 t = tracks[k];
              int64 s = t % 60l;
              t = t / 60l;
              minute = t % 60l;
              t = t / 60l;
              hour = t;
               
              mutable rstring timeasdf = "";
              if (hour < 10l) {
                timeasdf += "0";
              }
              timeasdf += (rstring) hour + ":";
              if (minute < 10l) {
                timeasdf += "0";
              }
              timeasdf += (rstring) minute + ":";
              if (s < 10l) {
                timeasdf += "0";
              }
              timeasdf += (rstring) s;
              
              mutable rstring asdf = "been here since " + timeasdf + ". current time is " + time;

              if (alarmed[k]) {

              } else {
                submit({time=asdf, id=k, phone="not yet"}, PartC);
                alarmed[k] = true;
              }
            }
          }
        }          
    }

    //dump output
    () as File = FileSink(PartA) {
      param file : "LocationLog.txt";
      format : csv;
    }
    () as File2 = FileSink(PartC) {
      param file : "UnsafeRoomAlert.txt";
      format : csv;
    }
}
