//TO RUN: ./output/bin/standalone stream="SensorData.csv" details="ChildDetails.csv"
composite childtracker {
  graph 
    //read in both files as CSVs
    stream<rstring time, rstring sensorid, rstring childid, rstring fromroom, rstring toroom> LineStream = FileSource() { 
      param 
        format : csv;
        hasHeaderLine : false;
        //defaultTuple : {time = "0", sensorid="default", childid="default", fromroom="default", toroom="default" };
        file : getSubmissionTimeValue("stream");
    }
   
    stream<rstring time, rstring id, rstring rm> PartA = Custom(LineStream) {
      logic
        state: {

          //map of childid, {timestamp, room}
          mutable map<rstring, tuple<int64 time, rstring room>> tracks = {};

          mutable int64 previous = -1l;
        }

        onTuple LineStream : {

          //parse the time into its components
          mutable int64 hour = -1;
          mutable int64 minute = -1;
          mutable float64 second = -1;

          list<rstring> components = tokenize(time, ":", false);
          parseNumber(hour,components[0]);
          parseNumber(minute,components[1]);
          parseNumber(second,components[2]);

          mutable int64 current = hour*60l*60l + minute*60l + (int64) second;

          tracks[childid] = {time=current, room=toroom};

          if (previous == -1l) {
            previous = current;
          } else {
            if (current - previous > 5l*60l) {
              previous = current;
              //output!

             for (rstring k in tracks) {
                mutable int64 t = tracks[k].time;
                int64 s = t % 60l;
                t = t / 60l;
                minute = t % 60l;
                t = t / 60l;
                hour = t;
                 
                mutable rstring timeasdf = "";
                if (hour < 10l) {
                  timeasdf += "0";
                }
                timeasdf += (rstring) hour + ":";
                if (minute < 10l) {
                  timeasdf += "0";
                }
                timeasdf += (rstring) minute + ":";
                if (s < 10l) {
                  timeasdf += "0";
                }
                timeasdf += (rstring) s;
                
                submit({time=timeasdf, id=k, rm=tracks[k].room}, PartA);
              }
            } else {
              //nothing. just keep collecting.
            }
          }
        }          
    }

    stream<rstring current, rstring id, rstring lastseen, rstring lastroom, rstring phone> PartB = Custom(LineStream) {
      logic
        state: {

          //map of childid, timestamp
          mutable map<rstring, int64> tracks = {};

          //map of childid, lastRoomSeen
          mutable map<rstring, rstring> rooms = {};

          //map of childid, alarmsounded
          mutable map<rstring, boolean> alarmed = {};
        }

        onTuple LineStream : {
      //Linestream: <rstring time, rstring sensorid, rstring childid, rstring fromroom, rstring toroom>
          mutable int64 hour = -1;
          mutable int64 minute = -1;
          mutable float64 second = -1;

          list<rstring> components = tokenize(time, ":", false);
          parseNumber(hour,components[0]);
          parseNumber(minute,components[1]);
          parseNumber(second,components[2]);

          mutable int64 current = hour*60l*60l + minute*60l + (int64) second;

          //should we check the difference before updating? Only edge case is if a single child has > 15 minutes between two records with no others in between
          tracks[childid] = current;
          alarmed[childid] = false;
          rooms[childid] = toroom;

          //gives us the value of the current time
          for (rstring k in tracks) {

            //compare NOW to the last sensor datum for the child and see if it's been 15 minutes
            if (current - tracks[k] > 15l*60l) {
              //danger!

              //all this string parsing was just helpful for debugging. remove before submission.
              mutable int64 t = tracks[k];
              int64 s = t % 60l;
              t = t / 60l;
              minute = t % 60l;
              t = t / 60l;
              hour = t;
               
              mutable rstring timeasdf = "";
              if (hour < 10l) {
                timeasdf += "0";
              }
              timeasdf += (rstring) hour + ":";
              if (minute < 10l) {
                timeasdf += "0";
              }
              timeasdf += (rstring) minute + ":";
              if (s < 10l) {
                timeasdf += "0";
              }
              timeasdf += (rstring) s;
              
              //mutable rstring asdf = "time last seen: " + timeasdf + ". current time is " + time;
              if (alarmed[k]) {

              } else {
                submit({current=time, id=k, lastseen=timeasdf, lastroom=rooms[k], phone="not yet"}, PartB);
                alarmed[k] = true;
              }
            }
          }
        }          
    }

    stream<rstring time, rstring id, rstring phone> PartC = Custom(LineStream) {
      logic
        state: {

          //map of childid, timestamp
          mutable map<rstring, int64> tracks = {};
          //map of childid, alarmsounded
          mutable map<rstring, boolean> alarmed = {};
        }

        onTuple LineStream : {
      //Linestream: <rstring time, rstring sensorid, rstring childid, rstring fromroom, rstring toroom>
          mutable int64 hour = -1;
          mutable int64 minute = -1;
          mutable float64 second = -1;

          list<rstring> components = tokenize(time, ":", false);
          parseNumber(hour,components[0]);
          parseNumber(minute,components[1]);
          parseNumber(second,components[2]);

          mutable int64 current = hour*60l*60l + minute*60l + (int64) second;
          if (toroom == "26") {
            //parse the time into its components
            tracks[childid] = current;
            alarmed[childid] = false;
          }
          if (fromroom == "26") {
            //alarmed[childid] = false;
          }

          //gives us the value of the current time
          for (rstring k in tracks) {

            //compare NOW to the entry point for the child and see if it's been 5 minutes
            if (current - tracks[k] > 5l*60l) {
              //danger!

              //all this string parsing was just helpful for debugging. remove before submission.
              mutable int64 t = tracks[k];
              int64 s = t % 60l;
              t = t / 60l;
              minute = t % 60l;
              t = t / 60l;
              hour = t;
               
              mutable rstring timeasdf = "";
              if (hour < 10l) {
                timeasdf += "0";
              }
              timeasdf += (rstring) hour + ":";
              if (minute < 10l) {
                timeasdf += "0";
              }
              timeasdf += (rstring) minute + ":";
              if (s < 10l) {
                timeasdf += "0";
              }
              timeasdf += (rstring) s;
              
              mutable rstring asdf = "been here since " + timeasdf + ". current time is " + time;

              if (alarmed[k]) {

              } else {
                submit({time=asdf, id=k, phone="not yet"}, PartC);
                alarmed[k] = true;
              }
            }
          }
        }          
    }

    stream<rstring time, rstring room, int32 children> PartD1 = Custom(LineStream) {
      logic
        state: {

          //TODO on other parts do I need to remove child from map when they exit the room?

          //map of room, map of childid, entry time
          mutable map<rstring, map<rstring, int64>> entries = {};
          //map of room, map of childid, exit time
          mutable map<rstring, map<rstring, int64>> exits = {};

          mutable int64 previous = -1l;
        }
        //Linestream: <rstring time, rstring sensorid, rstring childid, rstring fromroom, rstring toroom>
        onTuple LineStream : {

          //parse the time into its components
          mutable int64 hour = -1;
          mutable int64 minute = -1;
          mutable float64 second = -1;

          list<rstring> components = tokenize(time, ":", false);
          parseNumber(hour,components[0]);
          parseNumber(minute,components[1]);
          parseNumber(second,components[2]);

          mutable int64 current = hour*60l*60l + minute*60l + (int64) second;


          if (toroom in entries) {
            entries[toroom][childid] = current;
          } else {
            entries[toroom] = {childid:current};
          }
          //entries[toroom][childid] = current;
          if (fromroom in exits) {
            exits[fromroom][childid] = current;
          } else {
            exits[fromroom] = {childid:current};
          }
          //exits[fromroom][childid] = current;

          //do this so comparisons work later
          //this initializes the last known exit from a room to -1 if it doesn't yet exist
/*          if (toroom in exits) {
            if (childid in exits[toroom]) {
              //good to go. already exists. don't add it.
            } else {
              exits[toroom][childid] = -1l;
            }
          } else {
            exits[toroom] = {childid:-1l};
          }*/

          //visited = (entered room in last hour) OR (exited room in last hour) OR (exit time is before enter time [never exited])

          if (previous == -1l) {
            previous = current;
          } else {
            if (current - previous > 60l*60l) {
              //output!
              //map of room, set<children>
              mutable map<rstring, set<rstring>> outputs = {};
              for (rstring rm in entries) {
                for (rstring ch in entries[rm]) {
                  if (entries[rm][ch] >= previous) {
                    //output
                    if (rm in outputs) {
                      insertM(outputs[rm], ch);
                    } else {
                      outputs[rm] = {ch};
                    }
                  }
             
                  //ch is in entries[rm] at this point
                  if (ch in exits[rm]) {
                    if (exits[rm][ch] < entries[rm][ch]) {
                      insertM(outputs[rm], ch);
                    }
                  } else {
                    if (rm in outputs) {
                      insertM(outputs[rm], ch);
                    } else {
                      outputs[rm] = {ch};
                    }
                  }
                }
              }
              for (rstring rm in exits) {
                for (rstring ch in exits[rm]) {
                  if (exits[rm][ch] >= previous) {
                    //output
                      if (rm in outputs) {
                      insertM(outputs[rm], ch);
                    } else {
                      outputs[rm] = {ch};
                    }
                  }
                }
              }

              mutable int64 t = current;
              int64 s = t % 60l;
              t = t / 60l;
              minute = t % 60l;
              t = t / 60l;
              hour = t;
               
              mutable rstring timeasdf = "";
              if (hour < 10l) {
                timeasdf += "0";
              }
              timeasdf += (rstring) hour + ":";
              if (minute < 10l) {
                timeasdf += "0";
              }
              timeasdf += (rstring) minute + ":";
              if (s < 10l) {
                timeasdf += "0";
              }
              timeasdf += (rstring) s;
              
              for (rstring rm in outputs) {
                submit({time=timeasdf, room=rm, children=size(outputs[rm])}, PartD1);
              }
              previous = current;
            } else {
              //nothing. just keep collecting.
            }
          }
        }          
    }
    //dump output
    () as File = FileSink(PartA) {
      param file : "LocationLog.txt";
      format : csv;
    }
    () as File2 = FileSink(PartB) {
      param file : "MissingChildAlert.txt";
      format : csv;
    }
    () as File3 = FileSink(PartC) {
      param file : "UnsafeRoomAlert.txt";
      format : csv;
    }
    () as File4 = FileSink(PartD1) {
      param file : "RoomStats.txt";
      format : csv;
    }
}
